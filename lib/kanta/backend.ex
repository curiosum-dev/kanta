defmodule Kanta.Backend do
  alias Kanta.Utils.ModuleFolder
  require Logger

  # Define defaults consistent with Gettext where possible
  # No default adapter - it must be specified by the user
  # @default_adapter Kanta.Backend.Adapter.KantaCachedDB

  defmacro __using__(opts) do
    quote bind_quoted: [opts: opts] do
      require Logger
      # Flag file used by Kanta.Utils.GettextRecompiler
      # Needs to be coordinated if location changes.
      @flag_file "priv/kanta/.gettext_recompiled"
      gettext_opts = Keyword.drop(opts, [:adapter])

      # Store modules for runtime use in helpers
      @kanta_adapter Keyword.get(opts, :adapter, Kanta.Backend.Adapter.EctoDB)
      @kanta_plural_forms Keyword.get(opts, :plural_forms, Gettext.Plural)
      @kanta_interpolation Keyword.get(opts, :interpolation, Gettext.Interpolation.Default)

      # --- Fallback Backend Compilation ---
      # Compile the PO-file based fallback backend first.
      # It receives the standard gettext options like :otp_app, :priv,
      # :plural_forms, :interpolation etc.
      use Kanta.Backend.GettextFallback, gettext_opts

      # --- Main Backend Compilation & Extractor Handling ---
      if Gettext.Extractor.extracting?() do
        # For extraction (`mix gettext.extract`), use a standard Gettext backend setup
        # based on the provided options, so `gettext` calls are registered
        # correctly for POT file generation using the project's main :priv dir.
        use Gettext.Backend, gettext_opts
        # Set up the flag to force recompilation after extraction
        Kanta.Utils.GettextRecompiler.setup_recompile_flag(@flag_file)
      else
        # For runtime, use Gettext.Backend primarily to get the standard
        # Gettext behaviour boilerplate (__behaviour__, function heads, etc.)
        # and the __gettext__ info functions.
        # We use a dummy priv path specific to this module to avoid accidentally
        # compiling the *same* PO files as the fallback backend if the user
        # didn't override :priv in the main opts.
        # The functions generated by this `use Gettext.Backend` call are unlikely
        # to be hit directly, as lookups should fall through to the Kanta handlers.
        dummy_priv_opts =
          Keyword.merge(gettext_opts, priv: "priv/#{ModuleFolder.safe_folder_name(__MODULE__)}")

        use Gettext.Backend, dummy_priv_opts
      end

      # --- Kanta Runtime Logic Overrides ---

      # Override __mix_recompile__? to use Kanta's flag mechanism.
      def __mix_recompile__?() do
        Kanta.Utils.GettextRecompiler.needs_recompile?(@flag_file)
      end

      # Override __gettext__ functions as needed for consistency.
      # Get known locales from the *fallback* backend, as the DB content might differ
      # or might not be easily queryable for all distinct locales.
      def __gettext__(:known_locales) do
        fb_backend = fallback_backend()
        # Ensure the fallback module exists before calling it
        if Code.ensure_loaded?(fb_backend) do
          Gettext.known_locales(fb_backend)
        else
          Logger.error("Kanta: Fallback backend #{inspect(fb_backend)} not loaded.")
          # Return empty list if fallback isn't available
          []
        end
      end

      @impl Gettext.Backend
      # This function is called by Gettext when its compiled clauses for PO files
      # inside *this* module (if any were generated by the dummy `use Gettext.Backend` above)
      # don't match. We intercept it to try the database adapter first.
      def handle_missing_translation(locale, domain, msgctxt, msgid, bindings) do
        case @kanta_adapter.lookup_lgettext(locale, domain, msgctxt, msgid) do
          {:ok, raw_msgstr} ->
            # Found in DB: Apply interpolation at runtime
            {:ok, apply_interpolation(raw_msgstr, bindings)}

          {:error, :not_found} ->
            # Not in DB: Delegate to the PO file fallback backend
            fallback_backend().lgettext(locale, domain, msgctxt, msgid, bindings)
        end
      end

      @impl Gettext.Backend
      # This function is called by Gettext for non-matching plural lookups.
      def handle_missing_plural_translation(
            locale,
            domain,
            msgctxt,
            msgid,
            msgid_plural,
            n,
            bindings
          ) do
        # 1. Calculate plural index using configured module and LOCALE FIRST!
        # Pass locale
        plural_index = plural(locale, n)

        # 2. Call adapter with the calculated index to get the specific form string
        case @kanta_adapter.lookup_lngettext(
               locale,
               domain,
               msgctxt,
               msgid,
               msgid_plural,
               plural_index
             ) do
          {:ok, raw_msgstr} ->
            # Found the specific form in DB: Apply interpolation
            # a. Add :count to bindings for interpolation convenience
            extended_bindings = Map.put(bindings, :count, n)
            # b. Apply interpolation using configured module
            {:ok, apply_interpolation(raw_msgstr, extended_bindings)}

          {:error, :not_found} ->
            # DB lookup failed for this specific index/message combination.
            # Fallback to the PO file backend.
            Logger.debug(fn ->
              """
              Kanta: Plural form index #{plural_index} for count #{n} not found via adapter \
              for locale "#{locale}", domain "#{domain}", msgid "#{msgid}". \
              Falling back to PO files.
              """
            end)

            fallback_backend().lngettext(
              locale,
              domain,
              msgctxt,
              msgid,
              msgid_plural,
              n,
              bindings
            )
        end
      end

      # --- Generated Helper Functions ---

      # Helper to apply pluralization using the configured module and LOCALE.
      # Returns the plural form index (0, 1, 2...).
      defp plural(locale, n) when is_binary(locale) and is_integer(n) do
        try do
          @kanta_plural_forms.plural(locale, n)
        catch
          kind, reason ->
            # Log error if plural calculation fails (e.g., locale unknown to plural module)
            Logger.error("""
            Kanta: Error calling plural function (#{@kanta_plural_forms}.plural/2) \
            with locale=#{inspect(locale)}, n=#{n}. \
            Error: #{kind} - #{inspect(reason)}. \
            Returning default plural index 0.
            """)

            # Default to index 0 on error to prevent crashes, though translation may be wrong
            0
        end
      end

      # Helper to apply interpolation using the configured module at RUNTIME.
      defp apply_interpolation(raw_msgstr, bindings) when is_binary(raw_msgstr) do
        # Use the runtime `interpolate/2` function of the configured module
        @kanta_interpolation.runtime_interpolate(raw_msgstr, bindings)
      end

      # Helper to get the fallback module name.
      # Assumes Kanta.Backend.GettextFallback appends this suffix.
      defp fallback_backend() do
        Module.concat(__MODULE__, GettextFallbackBackend)
      end

      # Allow users to override the Kanta handlers if they need even more custom logic,
      # while still benefiting from the Kanta setup.
      defoverridable handle_missing_translation: 5, handle_missing_plural_translation: 7
    end

    # end quote
  end

  # end __using__
end

# end module
